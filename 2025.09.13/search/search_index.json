{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jaxace","text":"<p>JAX/Flax implementation of cosmological emulators with automatic JIT compilation.</p> <p>Key Features</p> <ul> <li>\u26a1 Automatic JIT compilation for optimal performance</li> <li>\ud83d\udd22 Full JAX integration with grad, vmap, and jit</li> <li>\ud83c\udf0c Cosmological functions for growth, distances, and Hubble parameter</li> <li>\ud83e\udde0 Neural network emulators with automatic batch detection</li> </ul>"},{"location":"#installation","title":"Installation","text":"pippoetry <pre><code>pip install -e .\n</code></pre> <pre><code>poetry install\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import jaxace\nimport jax.numpy as jnp\n\n# Define cosmology\ncosmo = jaxace.W0WaCDMCosmology(\n    ln10As=3.044, ns=0.9649, h=0.6736,\n    omega_b=0.02237, omega_c=0.1200,\n    m_nu=0.06, w0=-1.0, wa=0.0\n)\n\n# Compute background quantities\nz = jnp.array([0.0, 0.5, 1.0])\ngrowth = jaxace.D_z_from_cosmo(z, cosmo)\ndistance = jaxace.r_z_from_cosmo(z, cosmo)\n\n# Neural network emulator\nnn_dict = {...}  # Your network specification\nweights = np.load('weights.npy')\nemulator = jaxace.init_emulator(nn_dict, weights, jaxace.FlaxEmulator)\n\n# Run with automatic JIT\noutput = emulator(input_data)\n</code></pre>"},{"location":"#performance","title":"Performance","text":"<p>With automatic JIT compilation, jaxace achieves:</p> <ul> <li>Single evaluation: ~7 \u03bcs</li> <li>Batch processing: &gt;20M samples/sec</li> <li>Automatic optimization: No manual tuning required</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cosmology","title":"Cosmology","text":""},{"location":"api/#jaxace.W0WaCDMCosmology","title":"jaxace.W0WaCDMCosmology","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"api/#background-functions","title":"Background Functions","text":""},{"location":"api/#growth-functions","title":"Growth Functions","text":""},{"location":"api/#jaxace.D_z_from_cosmo","title":"jaxace.D_z_from_cosmo","text":"<pre><code>D_z_from_cosmo(z, cosmo: W0WaCDMCosmology)\n</code></pre>"},{"location":"api/#jaxace.f_z_from_cosmo","title":"jaxace.f_z_from_cosmo","text":"<pre><code>f_z_from_cosmo(z, cosmo: W0WaCDMCosmology)\n</code></pre>"},{"location":"api/#distance-functions","title":"Distance Functions","text":""},{"location":"api/#jaxace.r_z_from_cosmo","title":"jaxace.r_z_from_cosmo","text":"<pre><code>r_z_from_cosmo(z: Union[float, ndarray], cosmo: W0WaCDMCosmology) -&gt; Union[float, jnp.ndarray]\n</code></pre>"},{"location":"api/#jaxace.dA_z_from_cosmo","title":"jaxace.dA_z_from_cosmo","text":"<pre><code>dA_z_from_cosmo(z: Union[float, ndarray], cosmo: W0WaCDMCosmology) -&gt; Union[float, jnp.ndarray]\n</code></pre>"},{"location":"api/#jaxace.dL_z_from_cosmo","title":"jaxace.dL_z_from_cosmo","text":"<pre><code>dL_z_from_cosmo(z: Union[float, ndarray], cosmo: W0WaCDMCosmology) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Luminosity distance using cosmology structure.</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Union[float, ndarray]</code> <p>Redshift</p> required <code>cosmo</code> <code>W0WaCDMCosmology</code> <p>W0WaCDMCosmology structure</p> required <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Luminosity distance in Mpc</p>"},{"location":"api/#hubble-function","title":"Hubble Function","text":""},{"location":"api/#jaxace.E_z","title":"jaxace.E_z","text":"<pre><code>E_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless Hubble parameter E(z) = H(z)/H0.</p> <p>This is equivalent to E(a) with the transformation a = 1/(1+z).</p> <p>Handles NaN/Inf inputs by propagating them appropriately.</p>"},{"location":"api/#neural-network-emulators","title":"Neural Network Emulators","text":""},{"location":"api/#jaxace.init_emulator","title":"jaxace.init_emulator","text":"<pre><code>init_emulator(nn_dict: Dict[str, Any], weight: ndarray, emulator_type: Type[FlaxEmulator] = FlaxEmulator, validate: bool = True, validate_weights: Optional[bool] = None) -&gt; FlaxEmulator\n</code></pre> <p>Initialize an emulator from neural network dictionary and weights.</p> <p>Parameters:</p> Name Type Description Default <code>nn_dict</code> <code>Dict[str, Any]</code> <p>Neural network specification dictionary</p> required <code>weight</code> <code>ndarray</code> <p>Flattened weight array</p> required <code>emulator_type</code> <code>Type[FlaxEmulator]</code> <p>Type of emulator (currently only FlaxEmulator)</p> <code>FlaxEmulator</code> <code>validate</code> <code>bool</code> <p>Whether to validate nn_dict structure</p> <code>True</code> <code>validate_weights</code> <code>Optional[bool]</code> <p>Whether to validate weight dimensions</p> <code>None</code> <p>Returns:</p> Type Description <code>FlaxEmulator</code> <p>Initialized FlaxEmulator instance</p>"},{"location":"api/#jaxace.FlaxEmulator","title":"jaxace.FlaxEmulator  <code>dataclass</code>","text":"<pre><code>FlaxEmulator(model: Module, parameters: Dict[str, Any], states: Optional[Dict[str, Any]] = None, description: Dict[str, Any] = None)\n</code></pre> <p>               Bases: <code>AbstractTrainedEmulator</code></p> <p>Flax-based emulator with automatic JIT compilation.</p> <p>Key features: 1. Automatic JIT compilation on first use 2. Automatic batch detection and vmap application 3. Cached compiled functions for performance</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Module</code> <p>Flax model (nn.Module)</p> <code>parameters</code> <code>Dict[str, Any]</code> <p>Model parameters dictionary</p> <code>states</code> <code>Optional[Dict[str, Any]]</code> <p>Model states (usually empty for standard feedforward networks)</p> <code>description</code> <code>Dict[str, Any]</code> <p>Emulator description dictionary</p>"},{"location":"api/#jaxace.FlaxEmulator.run_emulator","title":"run_emulator","text":"<pre><code>run_emulator(input_data: Union[ndarray, ndarray]) -&gt; jnp.ndarray\n</code></pre> <p>Run the emulator with automatic JIT compilation and batch detection.</p> <p>This method automatically: 1. Converts numpy arrays to JAX arrays 2. Detects if input is a batch or single sample 3. Applies JIT compilation 4. Uses vmap for batch processing</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[ndarray, ndarray]</code> <p>Input array (single sample or batch)        Shape: (n_features,) for single or (n_samples, n_features) for batch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Output array from the neural network</p>"},{"location":"api/#jaxace.FlaxEmulator.__call__","title":"__call__","text":"<pre><code>__call__(input_data: Union[ndarray, ndarray]) -&gt; jnp.ndarray\n</code></pre> <p>Allow the emulator to be called directly as a function.</p>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#jaxace.maximin","title":"jaxace.maximin","text":"<pre><code>maximin(input_data: Union[ndarray, ndarray], minmax: Union[ndarray, ndarray]) -&gt; Union[np.ndarray, jnp.ndarray]\n</code></pre> <p>Normalize input data using min-max scaling. Matches Julia's maximin function.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[ndarray, ndarray]</code> <p>Input array to normalize (shape: (n_features,) or (n_features, n_samples))</p> required <code>minmax</code> <code>Union[ndarray, ndarray]</code> <p>Array of shape (n_features, 2) where column 0 is min, column 1 is max</p> required <p>Returns:</p> Type Description <code>Union[ndarray, ndarray]</code> <p>Normalized array in range [0, 1]</p>"},{"location":"api/#jaxace.inv_maximin","title":"jaxace.inv_maximin","text":"<pre><code>inv_maximin(output_data: Union[ndarray, ndarray], minmax: Union[ndarray, ndarray]) -&gt; Union[np.ndarray, jnp.ndarray]\n</code></pre> <p>Denormalize output data from min-max scaling. Matches Julia's inv_maximin function.</p> <p>Parameters:</p> Name Type Description Default <code>output_data</code> <code>Union[ndarray, ndarray]</code> <p>Normalized array (shape: (n_features,) or (n_features, n_samples))</p> required <code>minmax</code> <code>Union[ndarray, ndarray]</code> <p>Array of shape (n_features, 2) where column 0 is min, column 1 is max</p> required <p>Returns:</p> Type Description <code>Union[ndarray, ndarray]</code> <p>Denormalized array</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to jaxace! </p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/CosmologicalEmulators/jaxace.git\ncd jaxace\n\n# Install in development mode\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code>mkdocs serve  # Live preview at http://localhost:8000\nmkdocs build  # Build static site\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use standard Python formatting conventions. Please ensure your code is clean and well-documented.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Add tests if applicable</li> <li>Submit a pull request</li> </ol> <p>Thank you for contributing!</p>"}]}