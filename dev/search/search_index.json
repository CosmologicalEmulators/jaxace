{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jaxace","text":"<p>JAX/Flax implementation of cosmological emulators with automatic JIT compilation.</p> <p>Key Features</p> <ul> <li>\u26a1 Automatic JIT compilation for optimal performance</li> <li>\ud83d\udd22 Full JAX integration with grad, vmap, and jit</li> <li>\ud83c\udf0c Cosmological functions for growth, distances, and Hubble parameter</li> <li>\ud83e\udde0 Neural network emulators with automatic batch detection</li> </ul>"},{"location":"#installation","title":"Installation","text":"pippoetry <pre><code>pip install -e .\n</code></pre> <pre><code>poetry install\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import jaxace\nimport jax.numpy as jnp\n\n# Define cosmology\ncosmo = jaxace.w0waCDMCosmology(\n    ln10As=3.044, ns=0.9649, h=0.6736,\n    omega_b=0.02237, omega_c=0.1200,\n    m_nu=0.06, w0=-1.0, wa=0.0\n)\n\n# Compute background quantities\nz = jnp.array([0.0, 0.5, 1.0])\ngrowth = jaxace.D_z_from_cosmo(z, cosmo)\ndistance = jaxace.r_z_from_cosmo(z, cosmo)\n\n# Neural network emulator\nnn_dict = {...}  # Your network specification\nweights = np.load('weights.npy')\nemulator = jaxace.init_emulator(nn_dict, weights, jaxace.FlaxEmulator)\n\n# Run with automatic JIT\noutput = emulator(input_data)\n</code></pre>"},{"location":"#performance","title":"Performance","text":"<p>With automatic JIT compilation, jaxace achieves:</p> <ul> <li>Single evaluation: ~7 \u03bcs</li> <li>Batch processing: &gt;20M samples/sec</li> <li>Automatic optimization: No manual tuning required</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cosmology","title":"Cosmology","text":""},{"location":"api/#jaxace.w0waCDMCosmology","title":"jaxace.w0waCDMCosmology  <code>dataclass</code>","text":"<pre><code>w0waCDMCosmology(ln10As: float, ns: float, h: float, omega_b: float, omega_c: float, omega_k: float = 0.0, m_nu: float = 0.0, w0: float = -1.0, wa: float = 0.0)\n</code></pre>"},{"location":"api/#jaxace.w0waCDMCosmology.D_f_z","title":"D_f_z","text":"<pre><code>D_f_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Linear growth factor and growth rate (D(z), f(z)).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.D_z","title":"D_z","text":"<pre><code>D_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Linear growth factor D(z).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.E_a","title":"E_a","text":"<pre><code>E_a(a: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless Hubble parameter E(a) = H(a)/H0.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.E_z","title":"E_z","text":"<pre><code>E_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless Hubble parameter E(z) = H(z)/H0.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.dA_z","title":"dA_z","text":"<pre><code>dA_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Angular diameter distance in Mpc.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.dL_z","title":"dL_z","text":"<pre><code>dL_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Luminosity distance at redshift z in Mpc.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.dM_z","title":"dM_z","text":"<pre><code>dM_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Transverse comoving distance in Mpc (affected by curvature).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.d\u0303A_z","title":"d\u0303A_z","text":"<pre><code>d\u0303A_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless angular diameter distance d\u0303A(z).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.d\u0303M_z","title":"d\u0303M_z","text":"<pre><code>d\u0303M_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless transverse comoving distance d\u0303M(z).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.f_z","title":"f_z","text":"<pre><code>f_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Growth rate f(z) = d log D / d log a.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.r_z","title":"r_z","text":"<pre><code>r_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Line-of-sight comoving distance in Mpc.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.r\u0303_z","title":"r\u0303_z","text":"<pre><code>r\u0303_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless comoving distance r\u0303(z).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.\u03a9m_a","title":"\u03a9m_a","text":"<pre><code>\u03a9m_a(a: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Matter density parameter \u03a9\u2098(a) at scale factor a.</p>"},{"location":"api/#jaxace.w0waCDMCosmology.\u03a9tot_z","title":"\u03a9tot_z","text":"<pre><code>\u03a9tot_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Total density parameter at redshift z (always 1.0 for flat universe).</p>"},{"location":"api/#jaxace.w0waCDMCosmology.\u03c1c_z","title":"\u03c1c_z","text":"<pre><code>\u03c1c_z(z: Union[float, ndarray]) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Critical density at redshift z in M\u2609/Mpc\u00b3.</p>"},{"location":"api/#background-functions","title":"Background Functions","text":""},{"location":"api/#hubble-functions","title":"Hubble Functions","text":""},{"location":"api/#jaxace.E_z","title":"jaxace.E_z","text":"<pre><code>E_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless Hubble parameter E(z) = H(z)/H0.</p> <p>This is equivalent to E(a) with the transformation a = 1/(1+z).</p> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Hubble parameter E(z). Handles NaN/Inf inputs by propagating them appropriately.</p>"},{"location":"api/#jaxace.E_a","title":"jaxace.E_a","text":"<pre><code>E_a(a: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Dimensionless Hubble parameter E(a) = H(a)/H0.</p> <p>The normalized Hubble parameter is given by:</p> \\[E(a) = \\sqrt{\\Omega_{\\gamma,0} a^{-4} + \\Omega_{\\mathrm{cb},0} a^{-3} + \\Omega_{\\Lambda,0} \\rho_{\\mathrm{DE}}(a) + \\Omega_{\\nu}(a) + \\Omega_{k,0} a^{-2}}\\] <p>where:</p> <ul> <li>\\(\\Omega_{\\gamma,0}\\) is the photon density parameter today</li> <li>\\(\\Omega_{\\mathrm{cb},0}\\) is the cold dark matter + baryon density parameter today</li> <li>\\(\\Omega_{\\Lambda,0}\\) is the dark energy density parameter today (from flatness constraint)</li> <li>\\(\\rho_{\\mathrm{DE}}(a)\\) is the normalized dark energy density</li> <li>\\(\\Omega_{\\nu}(a)\\) is the massive neutrino contribution</li> <li>\\(\\Omega_{k,0}\\) is the curvature density parameter today</li> </ul> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Hubble parameter E(a). Handles NaN/Inf inputs by propagating them appropriately.</p> <code>Union[float, ndarray]</code> <p>Returns NaN for invalid parameter combinations.</p>"},{"location":"api/#jaxace.dlogEdloga","title":"jaxace.dlogEdloga","text":"<pre><code>dlogEdloga(a: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Logarithmic derivative of the Hubble parameter.</p> \\[\\frac{\\mathrm{d} \\ln E}{\\mathrm{d} \\ln a} = \\frac{a}{E} \\frac{\\mathrm{d}E}{\\mathrm{d}a}\\] <p>This quantity appears in the growth factor differential equation.</p> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Logarithmic derivative d(ln E)/d(ln a).</p>"},{"location":"api/#matter-density","title":"Matter Density","text":""},{"location":"api/#jaxace.\u03a9m_a","title":"jaxace.\u03a9m_a","text":"<pre><code>\u03a9m_a(a: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Matter density parameter \u03a9\u2098(a) at scale factor a.</p> \\[\\Omega_{\\mathrm{m}}(a) = \\frac{\\Omega_{\\mathrm{cb},0} a^{-3}}{E(a)^2}\\] <p>where E(a) is the normalized Hubble parameter.</p> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Matter density parameter \u03a9\u2098(a).</p>"},{"location":"api/#growth-functions","title":"Growth Functions","text":""},{"location":"api/#jaxace.D_z","title":"jaxace.D_z","text":"<pre><code>D_z(z, \u03a9cb0, h, m\u03bd=0.0, w0=-1.0, wa=0.0, \u03a9k0=0.0)\n</code></pre> <p>Linear growth factor D(z).</p> <p>The growth factor is normalized such that D(z=0) = 1. It satisfies the differential equation given in growth_solver.</p> <p>Returns:</p> Type Description <p>Linear growth factor D(z). Returns NaN for NaN inputs, handles invalid parameters gracefully.</p>"},{"location":"api/#jaxace.f_z","title":"jaxace.f_z","text":"<pre><code>f_z(z, \u03a9cb0, h, m\u03bd=0.0, w0=-1.0, wa=0.0, \u03a9k0=0.0)\n</code></pre> <p>Growth rate f(z) = d log D / d log a.</p> <p>The growth rate is defined as:</p> \\[f(z) = \\frac{\\mathrm{d} \\ln D}{\\mathrm{d} \\ln a}\\] <p>where D is the linear growth factor.</p> <p>Returns:</p> Type Description <p>Growth rate f(z). Returns NaN for NaN inputs, handles invalid parameters gracefully.</p>"},{"location":"api/#jaxace.D_f_z","title":"jaxace.D_f_z","text":"<pre><code>D_f_z(z, \u03a9cb0, h, m\u03bd=0.0, w0=-1.0, wa=0.0, \u03a9k0=0.0)\n</code></pre>"},{"location":"api/#distance-functions","title":"Distance Functions","text":""},{"location":"api/#jaxace.r_z","title":"jaxace.r_z","text":"<pre><code>r_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Line-of-sight comoving distance r(z) in Mpc.</p> <p>This is the conformal distance scaled to physical units. Independent of curvature (curvature only affects transverse distances).</p> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Line-of-sight comoving distance in Mpc</p>"},{"location":"api/#jaxace.dA_z","title":"jaxace.dA_z","text":"<pre><code>dA_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Angular diameter distance dA(z) in Mpc.</p> <p>For curved universes, uses transverse comoving distance: dA(z) = dM(z) / (1+z)</p> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Angular diameter distance in Mpc</p>"},{"location":"api/#jaxace.dL_z","title":"jaxace.dL_z","text":"<pre><code>dL_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre> <p>Luminosity distance at redshift z.</p> <p>For curved universes, uses transverse comoving distance: dL(z) = dM(z) * (1 + z)</p> <p>Parameters:</p> Name Type Description Default <code>z</code> <code>Union[float, ndarray]</code> <p>Redshift</p> required <code>\u03a9cb0</code> <code>Union[float, ndarray]</code> <p>Present-day matter density parameter (CDM + baryons)</p> required <code>h</code> <code>Union[float, ndarray]</code> <p>Dimensionless Hubble parameter (H0 = 100h km/s/Mpc)</p> required <code>m\u03bd</code> <code>Union[float, ndarray]</code> <p>Sum of neutrino masses in eV</p> <code>0.0</code> <code>w0</code> <code>Union[float, ndarray]</code> <p>Dark energy equation of state parameter</p> <code>-1.0</code> <code>wa</code> <code>Union[float, ndarray]</code> <p>Dark energy equation of state evolution parameter</p> <code>0.0</code> <code>\u03a9k0</code> <code>Union[float, ndarray]</code> <p>Curvature density parameter</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Union[float, ndarray]</code> <p>Luminosity distance in Mpc</p>"},{"location":"api/#density-functions","title":"Density Functions","text":""},{"location":"api/#jaxace.\u03c1c_z","title":"jaxace.\u03c1c_z","text":"<pre><code>\u03c1c_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0, \u03a9k0: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre>"},{"location":"api/#jaxace.\u03a9tot_z","title":"jaxace.\u03a9tot_z","text":"<pre><code>\u03a9tot_z(z: Union[float, ndarray], \u03a9cb0: Union[float, ndarray], h: Union[float, ndarray], m\u03bd: Union[float, ndarray] = 0.0, w0: Union[float, ndarray] = -1.0, wa: Union[float, ndarray] = 0.0) -&gt; Union[float, jnp.ndarray]\n</code></pre>"},{"location":"api/#utility-functions","title":"Utility Functions","text":""},{"location":"api/#jaxace.a_z","title":"jaxace.a_z","text":"<pre><code>a_z(z)\n</code></pre>"},{"location":"api/#neural-network-emulators","title":"Neural Network Emulators","text":""},{"location":"api/#jaxace.init_emulator","title":"jaxace.init_emulator","text":"<pre><code>init_emulator(nn_dict: Dict[str, Any], weight: ndarray, emulator_type: Type[FlaxEmulator] = FlaxEmulator, validate: bool = True, validate_weights: Optional[bool] = None) -&gt; FlaxEmulator\n</code></pre> <p>Initialize an emulator from neural network dictionary and weights.</p> <p>Parameters:</p> Name Type Description Default <code>nn_dict</code> <code>Dict[str, Any]</code> <p>Neural network specification dictionary</p> required <code>weight</code> <code>ndarray</code> <p>Flattened weight array</p> required <code>emulator_type</code> <code>Type[FlaxEmulator]</code> <p>Type of emulator (currently only FlaxEmulator)</p> <code>FlaxEmulator</code> <code>validate</code> <code>bool</code> <p>Whether to validate nn_dict structure</p> <code>True</code> <code>validate_weights</code> <code>Optional[bool]</code> <p>Whether to validate weight dimensions</p> <code>None</code> <p>Returns:</p> Type Description <code>FlaxEmulator</code> <p>Initialized FlaxEmulator instance</p>"},{"location":"api/#jaxace.FlaxEmulator","title":"jaxace.FlaxEmulator  <code>dataclass</code>","text":"<pre><code>FlaxEmulator(model: Module, parameters: Dict[str, Any], states: Optional[Dict[str, Any]] = None, description: Dict[str, Any] = None)\n</code></pre> <p>               Bases: <code>AbstractTrainedEmulator</code></p> <p>Flax-based emulator with automatic JIT compilation.</p> <p>Key features: 1. Automatic JIT compilation on first use 2. Automatic batch detection and vmap application 3. Cached compiled functions for performance</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>Module</code> <p>Flax model (nn.Module)</p> <code>parameters</code> <code>Dict[str, Any]</code> <p>Model parameters dictionary</p> <code>states</code> <code>Optional[Dict[str, Any]]</code> <p>Model states (usually empty for standard feedforward networks)</p> <code>description</code> <code>Dict[str, Any]</code> <p>Emulator description dictionary</p>"},{"location":"api/#jaxace.FlaxEmulator.run_emulator","title":"run_emulator","text":"<pre><code>run_emulator(input_data: Union[ndarray, ndarray]) -&gt; jnp.ndarray\n</code></pre> <p>Run the emulator with automatic JIT compilation and batch detection.</p> <p>This method automatically: 1. Converts numpy arrays to JAX arrays 2. Detects if input is a batch or single sample 3. Applies JIT compilation 4. Uses vmap for batch processing</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[ndarray, ndarray]</code> <p>Input array (single sample or batch)        Shape: (n_features,) for single or (n_samples, n_features) for batch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Output array from the neural network</p>"},{"location":"api/#jaxace.FlaxEmulator.__call__","title":"__call__","text":"<pre><code>__call__(input_data: Union[ndarray, ndarray]) -&gt; jnp.ndarray\n</code></pre> <p>Allow the emulator to be called directly as a function.</p>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#jaxace.maximin","title":"jaxace.maximin","text":"<pre><code>maximin(input_data: Union[ndarray, ndarray], minmax: Union[ndarray, ndarray]) -&gt; Union[np.ndarray, jnp.ndarray]\n</code></pre> <p>Normalize input data using min-max scaling. Matches Julia's maximin function.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[ndarray, ndarray]</code> <p>Input array to normalize (shape: (n_features,) or (n_features, n_samples))</p> required <code>minmax</code> <code>Union[ndarray, ndarray]</code> <p>Array of shape (n_features, 2) where column 0 is min, column 1 is max</p> required <p>Returns:</p> Type Description <code>Union[ndarray, ndarray]</code> <p>Normalized array in range [0, 1]</p>"},{"location":"api/#jaxace.inv_maximin","title":"jaxace.inv_maximin","text":"<pre><code>inv_maximin(output_data: Union[ndarray, ndarray], minmax: Union[ndarray, ndarray]) -&gt; Union[np.ndarray, jnp.ndarray]\n</code></pre> <p>Denormalize output data from min-max scaling. Matches Julia's inv_maximin function.</p> <p>Parameters:</p> Name Type Description Default <code>output_data</code> <code>Union[ndarray, ndarray]</code> <p>Normalized array (shape: (n_features,) or (n_features, n_samples))</p> required <code>minmax</code> <code>Union[ndarray, ndarray]</code> <p>Array of shape (n_features, 2) where column 0 is min, column 1 is max</p> required <p>Returns:</p> Type Description <code>Union[ndarray, ndarray]</code> <p>Denormalized array</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to jaxace! </p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/CosmologicalEmulators/jaxace.git\ncd jaxace\n\n# Install in development mode\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code>mkdocs serve  # Live preview at http://localhost:8000\nmkdocs build  # Build static site\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use standard Python formatting conventions. Please ensure your code is clean and well-documented.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes</li> <li>Add tests if applicable</li> <li>Submit a pull request</li> </ol> <p>Thank you for contributing!</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-cosmology-calculations","title":"Basic Cosmology Calculations","text":"<p>This example demonstrates how to use the <code>w0waCDMCosmology</code> class to compute various cosmological quantities and visualize them.</p>"},{"location":"examples/#setting-up-the-cosmology","title":"Setting up the Cosmology","text":"<p>First, let's create a cosmology instance with standard \u039bCDM parameters (Planck 2018):</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport jaxace\n\n# Create a cosmology instance with Planck 2018 parameters\ncosmo = jaxace.w0waCDMCosmology(\n    ln10As=3.044,      # ln(10^10 A_s)\n    ns=0.9649,         # Scalar spectral index\n    h=0.6736,          # Hubble parameter\n    omega_b=0.02237,   # Baryon density\n    omega_c=0.1200,    # CDM density\n    m_nu=0.06,         # Sum of neutrino masses in eV\n    w0=-1.0,           # Dark energy equation of state\n    wa=0.0             # Dark energy evolution parameter\n)\n</code></pre>"},{"location":"examples/#computing-distances","title":"Computing Distances","text":"<p>Now let's compute the comoving distance for a range of redshifts:</p> <pre><code># Create redshift array from 0 to 3\nz = jnp.linspace(0.01, 3.0, 100)\n\n# Compute comoving distance\nr_comoving = cosmo.r_z(z)\n\n# Also compute angular diameter and luminosity distances\ndA = cosmo.dA_z(z)\ndL = cosmo.dL_z(z)\n</code></pre>"},{"location":"examples/#computing-growth-functions","title":"Computing Growth Functions","text":"<p>Let's compute the linear growth factor and growth rate:</p> <pre><code># Compute growth factor D(z) and growth rate f(z)\nD = cosmo.D_z(z)\nf = cosmo.f_z(z)\n\n# We can also get both at once for efficiency\nD_both, f_both = cosmo.D_f_z(z)\n</code></pre>"},{"location":"examples/#visualizing-the-results","title":"Visualizing the Results","text":"<p>Now let's create plots to visualize these cosmological quantities:</p> <pre><code># Create a figure with subplots\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# Plot 1: Distance measures\nax = axes[0, 0]\nax.plot(z, r_comoving, label='Comoving distance $r(z)$', linewidth=2)\nax.plot(z, dA, label='Angular diameter distance $d_A(z)$', linewidth=2)\nax.plot(z, dL, label='Luminosity distance $d_L(z)$', linewidth=2)\nax.set_xlabel('Redshift $z$')\nax.set_ylabel('Distance [Mpc]')\nax.set_title('Cosmological Distances')\nax.legend()\nax.grid(True, alpha=0.3)\n\n# Plot 2: Hubble parameter\nax = axes[0, 1]\nE_z = jaxace.E_z(z, cosmo.omega_b + cosmo.omega_c, cosmo.h,\n                 m\u03bd=cosmo.m_nu, w0=cosmo.w0, wa=cosmo.wa)\nH_z = 100 * cosmo.h * E_z  # H(z) in km/s/Mpc\nax.plot(z, H_z, color='darkblue', linewidth=2)\nax.set_xlabel('Redshift $z$')\nax.set_ylabel('$H(z)$ [km/s/Mpc]')\nax.set_title('Hubble Parameter Evolution')\nax.grid(True, alpha=0.3)\n\n# Plot 3: Growth factor\nax = axes[1, 0]\nax.plot(z, D, color='darkgreen', linewidth=2)\nax.set_xlabel('Redshift $z$')\nax.set_ylabel('$D(z)$')\nax.set_title('Linear Growth Factor')\nax.grid(True, alpha=0.3)\nax.invert_xaxis()  # Convention: D grows as z decreases\n\n# Plot 4: Growth rate\nax = axes[1, 1]\nax.plot(z, f, color='darkred', linewidth=2)\nax.set_xlabel('Redshift $z$')\nax.set_ylabel('$f(z) = d\\\\ln D / d\\\\ln a$')\nax.set_title('Growth Rate')\nax.grid(True, alpha=0.3)\nax.set_ylim([0.4, 1.0])\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/#using-jax-features","title":"Using JAX Features","text":"<p>One of the advantages of <code>jaxace</code> is that all functions are JAX-compatible, enabling automatic differentiation and JIT compilation:</p> <pre><code># JIT compile for faster repeated calculations\n@jax.jit\ndef compute_distances_fast(z_array, omega_c, omega_b, h):\n    \"\"\"JIT-compiled function for fast distance calculations.\"\"\"\n    cosmo = jaxace.w0waCDMCosmology(\n        ln10As=3.044, ns=0.9649, h=h,\n        omega_b=omega_b, omega_c=omega_c,\n        m_nu=0.06, w0=-1.0, wa=0.0\n    )\n    return cosmo.r_z(z_array)\n\n# Compute gradient with respect to cosmological parameters\ngrad_fn = jax.grad(lambda omega_c: compute_distances_fast(\n    jnp.array([1.0]), omega_c, 0.02237, 0.6736\n).sum())\n\n# Calculate derivative of comoving distance at z=1 with respect to omega_c\nd_r_d_omega_c = grad_fn(0.12)\nprint(f\"\u2202r(z=1)/\u2202\u03a9_c = {d_r_d_omega_c:.2f} Mpc\")\n</code></pre>"},{"location":"examples/#computing-jacobians-of-growth-functions","title":"Computing Jacobians of Growth Functions","text":"<p>A powerful feature of <code>jaxace</code> is the ability to compute Jacobians (derivatives) of cosmological quantities with respect to all input parameters simultaneously:</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport jaxace\n\n# Define a function that computes growth factor for given parameters\ndef growth_factor_function(params, z):\n    \"\"\"Compute growth factor D(z) for given cosmological parameters.\"\"\"\n    omega_c, omega_b, h, m_nu, w0, wa = params\n    cosmo = jaxace.w0waCDMCosmology(\n        ln10As=3.044,  # Keep fixed for this example\n        ns=0.9649,      # Keep fixed for this example\n        h=h,\n        omega_b=omega_b,\n        omega_c=omega_c,\n        m_nu=m_nu,\n        w0=w0,\n        wa=wa\n    )\n    return cosmo.D_z(z)\n\n# Define fiducial parameters (Planck 2018)\nfiducial_params = jnp.array([\n    0.1200,   # omega_c\n    0.02237,  # omega_b\n    0.6736,   # h\n    0.06,     # m_nu (eV)\n    -1.0,     # w0\n    0.0       # wa\n])\n\n# Redshift array\nz = jnp.linspace(0.01, 3.0, 50)\n\n# Compute Jacobian matrix: dD/d\u03b8 for all parameters at all redshifts\njacobian_fn = jax.jacobian(growth_factor_function, argnums=0)\njacobian = jacobian_fn(fiducial_params, z)\n\n# jacobian shape is (n_z, n_params)\nprint(f\"Jacobian shape: {jacobian.shape}\")\nprint(f\"Parameters: [omega_c, omega_b, h, m_nu, w0, wa]\")\n\n# Plot the derivatives\nfig, axes = plt.subplots(2, 3, figsize=(15, 10))\nparam_names = ['$\\\\Omega_c$', '$\\\\Omega_b$', '$h$', '$m_\\\\nu$ [eV]', '$w_0$', '$w_a$']\nparam_labels = ['omega_c', 'omega_b', 'h', 'm_nu', 'w0', 'wa']\n\nfor i, (ax, name, label) in enumerate(zip(axes.flat, param_names, param_labels)):\n    ax.plot(z, jacobian[:, i], linewidth=2.5, color=plt.cm.viridis(i/5))\n    ax.set_xlabel('Redshift $z$')\n    ax.set_ylabel(f'$\\\\partial D/\\\\partial${name}')\n    ax.set_title(f'Growth Factor Sensitivity to {name}')\n    ax.grid(True, alpha=0.3)\n    ax.axhline(y=0, color='k', linestyle='--', alpha=0.3)\n\n    # Add text with max sensitivity\n    max_idx = jnp.argmax(jnp.abs(jacobian[:, i]))\n    max_z = z[max_idx]\n    max_val = jacobian[max_idx, i]\n    ax.text(0.95, 0.95, f'Max at z={max_z:.2f}\\\\n\u2202D/\u2202{label}={max_val:.3f}',\n            transform=ax.transAxes, ha='right', va='top',\n            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n\nplt.suptitle('Jacobian of Growth Factor D(z) w.r.t. Cosmological Parameters',\n             fontsize=16, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/#computing-jacobians-for-multiple-quantities","title":"Computing Jacobians for Multiple Quantities","text":"<p>We can also compute Jacobians for both growth factor D(z) and growth rate f(z) simultaneously:</p> <pre><code># Define a function that returns both D and f\ndef growth_functions(params, z):\n    \"\"\"Compute both D(z) and f(z) for given parameters.\"\"\"\n    omega_c, omega_b, h, m_nu, w0, wa = params\n    cosmo = jaxace.w0waCDMCosmology(\n        ln10As=3.044, ns=0.9649,\n        h=h, omega_b=omega_b, omega_c=omega_c,\n        m_nu=m_nu, w0=w0, wa=wa\n    )\n    D, f = cosmo.D_f_z(z)\n    return jnp.stack([D, f])  # Stack to get shape (2, n_z)\n\n# Compute Jacobian for both quantities\njacobian_both_fn = jax.jacobian(growth_functions, argnums=0)\njacobian_both = jacobian_both_fn(fiducial_params, z)\n\n# jacobian_both shape is (2, n_z, n_params)\n# where index 0 is D(z) and index 1 is f(z)\njacobian_D = jacobian_both[0]  # Shape: (n_z, n_params)\njacobian_f = jacobian_both[1]  # Shape: (n_z, n_params)\n\n# Plot comparison of sensitivities for D and f\nfig, axes = plt.subplots(2, 3, figsize=(15, 10))\n\nfor i, (ax, name, label) in enumerate(zip(axes.flat, param_names, param_labels)):\n    ax.plot(z, jacobian_D[:, i], label='$\\\\partial D/\\\\partial$' + name,\n            linewidth=2.5, color='blue')\n    ax.plot(z, jacobian_f[:, i], label='$\\\\partial f/\\\\partial$' + name,\n            linewidth=2.5, color='red', linestyle='--')\n    ax.set_xlabel('Redshift $z$')\n    ax.set_ylabel('Derivative')\n    ax.set_title(f'Sensitivity to {name}')\n    ax.legend(loc='best')\n    ax.grid(True, alpha=0.3)\n    ax.axhline(y=0, color='k', linestyle=':', alpha=0.3)\n\nplt.suptitle('Comparison of D(z) and f(z) Sensitivities',\n             fontsize=16, fontweight='bold')\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/#comparing-different-cosmologies","title":"Comparing Different Cosmologies","text":"<p>Let's compare how different dark energy models affect the growth of structure:</p> <pre><code># Define different cosmologies\ncosmologies = {\n    '\u039bCDM': {'w0': -1.0, 'wa': 0.0},\n    'wCDM': {'w0': -0.9, 'wa': 0.0},\n    'w0waCDM': {'w0': -0.95, 'wa': 0.3},\n}\n\n# Compute growth factors for each cosmology\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\nfor name, params in cosmologies.items():\n    cosmo_test = jaxace.w0waCDMCosmology(\n        ln10As=3.044, ns=0.9649, h=0.6736,\n        omega_b=0.02237, omega_c=0.1200,\n        m_nu=0.06, **params\n    )\n\n    D_test = cosmo_test.D_z(z)\n    f_test = cosmo_test.f_z(z)\n\n    ax1.plot(z, D_test, label=name, linewidth=2)\n    ax2.plot(z, f_test, label=name, linewidth=2)\n\nax1.set_xlabel('Redshift $z$')\nax1.set_ylabel('$D(z)$')\nax1.set_title('Growth Factor Comparison')\nax1.legend()\nax1.grid(True, alpha=0.3)\nax1.invert_xaxis()\n\nax2.set_xlabel('Redshift $z$')\nax2.set_ylabel('$f(z)$')\nax2.set_title('Growth Rate Comparison')\nax2.legend()\nax2.grid(True, alpha=0.3)\nax2.set_ylim([0.4, 1.0])\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/#performance-tips","title":"Performance Tips","text":""},{"location":"examples/#jit-compilation","title":"JIT Compilation","text":"<p>For optimal performance, especially when computing many values:</p> <pre><code># JIT compile the entire calculation pipeline\n@jax.jit\ndef compute_all_quantities(z_array, cosmo):\n    \"\"\"Compute all cosmological quantities at once.\"\"\"\n    r = cosmo.r_z(z_array)\n    D, f = cosmo.D_f_z(z_array)\n    return r, D, f\n\n# First call will compile\nz_test = jnp.linspace(0.01, 3.0, 1000)\nr, D, f = compute_all_quantities(z_test, cosmo)\n\n# Subsequent calls will be much faster\n%timeit compute_all_quantities(z_test, cosmo)\n</code></pre>"},{"location":"examples/#vectorization","title":"Vectorization","text":"<p>All functions support vectorized inputs for efficient batch calculations:</p> <pre><code># Compute for multiple redshifts at once (vectorized)\nz_grid = jnp.logspace(-2, 0.5, 50)  # z from 0.01 to ~3.16\nr_grid = cosmo.r_z(z_grid)\n\n# This is much faster than a loop:\n# for zi in z_grid:\n#     ri = cosmo.r_z(zi)  # Slower!\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed function documentation</li> <li>Check the neutrino mass effects by varying <code>m_nu</code></li> <li>Experiment with different dark energy models using <code>w0</code> and <code>wa</code></li> <li>Use JAX's automatic differentiation to compute derivatives of cosmological quantities</li> </ul>"}]}